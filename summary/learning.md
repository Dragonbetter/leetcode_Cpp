# 代码随想录总结

## 数组总结篇

### 数组理论基础

数组是存放在连续内存空间上的相同类型数据的集合；

数组下标都是从0开始的。
数组内存空间的地址是连续的。
数组的元素是不能删的，只能覆盖。

二分法 (左闭右闭 左闭右开)\
双指针法（快慢指针法）：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
（相向双指针法） \
滑动窗口 在于根据当前子序列和大小的情况，不断调节子序列的起始位置\
模拟行为 循环不变量原则

## 链表

### 链表理论基础

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。
链表的入口节点称为链表的头结点也就是head \
单链表: 指针域只能指向节点的下一个节点。\
双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点. \
循环链表:链表首尾相连,解决约瑟夫环.

#### 链表的定义

```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

链表的增添和删除都是O(1)操作，也不会影响到其他节点。但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

#### 直接使用原来的链表来进行删除操作

移除头结点和移除其他节点的操作是一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。
其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点

#### 设置一个虚拟头结点在进行删除操作

链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。

#### 链表的基本操作

获取链表第index个节点的数值
在链表的最前面插入一个节点
在链表的最后面插入一个节点
在链表第index个节点前面插入一个节点
删除链表的第index个节点的数值

#### 反转链表 高频题目

迭代法和递归法两个指针

#### 删除倒数第N个节点

虚拟头结点 和 双指针法来移除链表倒数第N个节点。

#### 链表相交

双指针来找到两个链表的交点（引用完全相同，即：内存地址完全相同的交点）

### 环形链表 数学证明 较难

在链表如何找环，以及如何找环的入口位置。

## 哈希表

### 哈希表理论基础

#### 哈希表定义

哈希表是根据关键码的值而直接进行访问的数据结构。\
一般哈希表都是用来快速判断一个元素是否出现集合里。

#### 哈希函数

哈希函数，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

#### 哈希碰撞

拉链法: \
发生冲突的元素都被存储在该hash表对应位置的链表中=>其实拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间 \
线性探测法:\
 线性探测法，一定要保证tableSize大于dataSize,依靠哈希表中的空位来解决碰撞问题

### 常见的三种哈希结构

#### 数组 set （集合）map(映射)

数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。
所以此时一样的做映射的话，就可以使用set了。

关于set，C++ 给提供了如下三种可用的数据结构：\
std::set \
std::multiset \
std::unordered_set \
std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 使用unordered_set 读写效率是最高的，本题并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。\

C++提供如下三种map：\
std::map \
std::multimap \
std::unordered_map \
std::unordered_map 底层实现为哈希，std::map 和std::multimap 的底层实现是红黑树。
同理，std::map 和std::multimap 的key也是有序的。

## 字符串

### 字符串和数组

字符串是若干字符组成的有限序列 \
在C语言中，把一个字符串存入一个数组时，也把结束符'\0'存入数组，并以此作为该字符串是否结束的标志。 \
在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。但string其实不会保存结束符。\
vector< char > 和 string：在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口。

### KMP->字符串匹配

KMP：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。

因为 KMP 利用已匹配部分中相同的「前缀」和「后缀」来加速下一次的匹配。

因为 KMP 的原串指针不会进行回溯（没有朴素匹配中回到下一个「发起点」的过程）

### 前缀表

前缀表：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\
记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀

前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。 \
后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。 \
因为前缀表要求的就是相同前后缀的长度。 \

为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配？

`文本串: a a b a a b a a f`\
`下表  : 0 1 2 3 4 5` \
`模式串：a a b a a f` \
`前缀表：0 1 0 1 2 0`

下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

### next数组[构建过程比较复杂]

next数组来做回退操作，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。

n为文本串长度，m为模式串长度，因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。所以整个KMP算法的时间复杂度是O(n+m)的。

关于指针回溯求next的理解
每次求next【i】，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针移到next【j-1】上。
求next过程实际上是dp（动态规划），只与前一个状态有关：
若不匹配，一直往前退到0或匹配为止
若匹配，则将之前的结果传递：
因为之前的结果不为0时，前后缀有相等的部分，所以j所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从前缀开始匹配了，所以之前的结果是可以传递的。

===================================================

算法针对的是子串有对称属性，如果有对称属性，那么就需要向前查找是否有可以再次匹配的内容;对称不是中心对称，而是中心字符块对称，比如不是abccba，而是abcabc这种对称。

a、当前面字符的前一个字符的对称程度为0的时候，只要将当前字符与子串第一个字符进行比较。这个很好理解啊，前面都是0，说明都不对称了，如果多加了一个字符，要对称的话最多是当前的和第一个对称。比如agcta这个里面t的是0，那么后面的a的对称程度只需要看它是不是等于第一个字符a了。

b、按照这个推理，我们就可以总结一个规律，不仅前面是0呀，如果前面一个字符的next值是1，那么我们就把当前字符与子串第二个字符进行比较，因为前面的是1，说明前面的字符已经和第一个相等了，如果这个又与第二个相等了，说明对称程度就是2了。有两个字符对称了。比如上面agctag，倒数第二个a的next是1，说明它和第一个a对称了，接着我们就把最后一个g与第二个g比较，又相等，自然对称成都就累加了，就是2了。

c、按照上面的推理，如果一直相等，就一直累加，可以一直推啊，推到这里应该一点难度都没有吧，如果你觉得有难度说明我写的太失败了。

KMP 算法的应用范围要比 Manacher 算法广，Manacher 算法只能应用于「回文串」问题，相对比较局限，而「子串匹配」问题还是十分常见的。

==========================================

双指针法：其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。

反转系列：当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。

先整体反转再局部反转// 先局部反转再整体反转

```C++
void  getnext(int *next,const string &s,){
    // 需要能实时的修改数据的情况 故而传入数组的指针和字符串的引用类型
    // 获得前缀表 双指针 j指向0，i指向1初始情况
    int j=0;
    next[0]=0;
    for(int i=1;i<s.size();i++){
        while(j>0 && s[i]!=s[j]){ // 不相等的情况下反复回退
           // j如果可以等于0 则无法回退了 因为没有next[-1]
           j = next[j-1];
        }
        if(s[i]==s[j]){
            // 匹配的情况下 加1
            j++;
        }
        next[i] = j;
    }
}
// 寻找子串的方法
bool strStr(string haystack,string needle){
    // needle 为模仿子串 需要获取他的前缀表
    if(needle.size()==0){
        return 0;
    }
    int next[needle.size()];
    getnext(next,needle);
    // 开始匹配
    int j=0;
    for(int i=0;i<haystack.size();i++){
        while(j>0 && haystack[i]!=needle[j]){
            // 重点在于此处的不匹配情况分析 回退
            j = next[j-1];
        }
        if(haystack[i]==needle[j]){
            j++;
        }
        if(j==needle.size()){
            // 说明到达了末尾 
            return (i-needle.size()+1);
        }
    }
    return -1;
}
```

## 栈与队列理论基础

### 问题思考

1.C++中stack 是容器么？\
2.我们使用的stack是属于哪个版本的STL？\
3.我们使用的STL中stack是如何实现的？ \
4.stack 提供迭代器来遍历stack空间么？

=>栈和队列是STL（C++标准库）里面的两个数据结构,C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。

### 栈=》栈不被归类为容器，被归类为容器适配器

栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。

===============================================
栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）\

功能：pop()(删除栈顶元素，但不返回该元素的值),top(返回栈顶元素的值，但不删除)push(item),emplace(args)(创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，也可以通过由args构造而来)

底层实现：默认的是deque（双端队列），也可以是vector，list（双向链表）；可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数。 \
==》  \
陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中不一定是连续分布的。
陷阱2：缺省情况下，默认底层容器是deque，那么deque在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

```C++
std::stack<int,std::vector<int>> third; // 使用vector为底层容器的栈
```

### 队列=》先进先出的数据结构，同样不允许有遍历行为，不提供迭代器

==============================================
功能：pop()(删除queue的首元素，但不返回此元素？),front(返回首元素但不删除此元素),back(返回尾元素),push(item),emplace(args)(在queue末尾创建一个元素，其值为item，或则由args构建而成)

底层实现：默认基于queue实现，也可以基于list构建，但不能基于vector。

``` C++
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
```

### 优先队列=》 常数时间复杂度的最大元素查找，以及对数时间复杂度的插入和删除

std::priority_queue通常实现为一个最大堆结构，但它的具体实现可能依赖于标准库的实现。

#### 基本特征

底层数据结构：std::priority_queue 通常使用一个动态数组来实现堆结构，这在大多数情况下是通过std::vector来实现的。\
元素排序：元素按照优先级排序，其中优先级最高的元素总是位于队列的前端。默认情况下，使用元素类型的<操作符来确定优先级，但也可以通过提供自定义比较函数来改变排序准则. \
访问元素：只能访问队列中优先级最高的元素（即堆顶元素）。不支持遍历或访问其他元素。\
修改队列：可以添加新元素，也可以移除堆顶元素。添加新元素时，元素会自动移动到正确的位置以保持堆的性质。

#### 操作复杂度

插入操作 (push)：对数时间复杂度（O(log n)），因为需要将新元素上浮到正确的位置。 \
删除最大元素 (pop)：对数时间复杂度，因为移除堆顶元素后，需要重新调整堆来找到下一个最大元素。 \
访问最大元素 (top)：常数时间复杂度（O(1)），因为最大元素总是在堆的顶部。

```C++
class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
// 参数类型<1.存储的数据类型 2.底层实现的类型 3.比较器的类型 >
```

## 二叉树

### 二叉树的种类

#### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
深度为k，有2^k-1个节点的二叉树

#### 完全二叉树

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。

#### 二叉搜索树

二叉搜索树是有数值的了，二叉搜索树是一个有序树。 \
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； \
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； \
它的左、右子树也分别为二叉排序树。

#### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

### 二叉树的存储方式

二叉树可以链式存储，也可以顺序存储。\
链式存储方式就用指针(通过指针把分布在各个地址的节点串联一起/最终的叶子节点指针指向NULL)
顺序存储的方式就是用数组(元素在内存是连续分布的)。

### 二叉树的遍历方式

- 深度优先遍历（先往深走，遇到叶子节点再往回走）
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历（一层一层的去遍历）
  - 层次遍历（迭代法）

栈其实就是递归的一种实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

使用栈来模拟深度遍历，使用队列来模拟广度遍历

### 二叉树的定义

```C++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

### 二叉树的递归遍历

1.确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

2.确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

3.确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 易误解概念

二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。\
二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。\
leetcode中强调的深度和高度很明显是按照节点来计算的。
![深度高度](深度高度.png)
关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以leetcode为准。\
求深度的逻辑 从上到下 前序遍历
求高度的逻辑 从下到上 后序遍历

### 递归函数什么时候要有返回值，什么时候没有返回值，特别是有的时候递归函数返回类型为bool类型

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）\
如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在236. 二叉树的最近公共祖先 (opens new window)中介绍）\
如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

### 前中后序构建树

前序和中序可以唯一确定一棵二叉树。\
后序和中序可以唯一确定一棵二叉树。\
前序和后序不能唯一确定一棵二叉树！\
因为没有中序遍历无法确定左右部分，也就是无法分割。\
学会打日志来调试（如何打日志有时候也是个技术活），不要脑动模拟，脑动模拟很容易越想越乱。

### 同时处理两棵树

迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解。