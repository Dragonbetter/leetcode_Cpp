// 提示：涉及到车道线3次曲线方程
pLCFSENreqPorts->sLCFLaneData.abAvailable[0] = 1U;
pLCFSENreqPorts->sLCFLaneData.afCurvatureChange_1pm2[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afCurvature_1pm[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afEventDistance_met[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvatureChange_1pm2[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvature_1pm[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevHeadingAngle_rad[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevPosY0_met[0] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afValidLength_met[0] = 100.f;
pLCFSENreqPorts->sLCFLaneData.auColor_nu[0] = 0U;
pLCFSENreqPorts->sLCFLaneData.auEventQuality_nu[0] = 0u;
pLCFSENreqPorts->sLCFLaneData.auEventType_nu[0] = 0u;
pLCFSENreqPorts->sLCFLaneData.auMarkerType_nu[0] = 2U;
pLCFSENreqPorts->sLCFLaneData.auQuality_nu[0] = 100U;

pLCFSENreqPorts->sLCFLaneData.abAvailable[1] = 1U;
pLCFSENreqPorts->sLCFLaneData.afCurvatureChange_1pm2[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afCurvature_1pm[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afEventDistance_met[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvatureChange_1pm2[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvature_1pm[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevHeadingAngle_rad[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevPosY0_met[1] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afValidLength_met[1] = 100.f;
pLCFSENreqPorts->sLCFLaneData.auColor_nu[1] = 0U;
pLCFSENreqPorts->sLCFLaneData.auEventQuality_nu[1] = 0u;
pLCFSENreqPorts->sLCFLaneData.auEventType_nu[1] = 0u;
pLCFSENreqPorts->sLCFLaneData.auMarkerType_nu[1] = 2U;
pLCFSENreqPorts->sLCFLaneData.auQuality_nu[1] = 100U;

pLCFSENreqPorts->sLCFLaneData.abAvailable[2] = 1U;
pLCFSENreqPorts->sLCFLaneData.afCurvatureChange_1pm2[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afCurvature_1pm[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afEventDistance_met[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvatureChange_1pm2[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvature_1pm[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevHeadingAngle_rad[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevPosY0_met[2] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afValidLength_met[2] = 100.f;
pLCFSENreqPorts->sLCFLaneData.auColor_nu[2] = 0U;
pLCFSENreqPorts->sLCFLaneData.auEventQuality_nu[2] = 0u;
pLCFSENreqPorts->sLCFLaneData.auEventType_nu[2] = 0u;
pLCFSENreqPorts->sLCFLaneData.auMarkerType_nu[2] = 2U;
pLCFSENreqPorts->sLCFLaneData.auQuality_nu[2] = 100U;

pLCFSENreqPorts->sLCFLaneData.abAvailable[3] = 1U;
pLCFSENreqPorts->sLCFLaneData.afCurvatureChange_1pm2[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afCurvature_1pm[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afEventDistance_met[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvatureChange_1pm2[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevCurvature_1pm[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevHeadingAngle_rad[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afStdDevPosY0_met[3] = 0.f;
pLCFSENreqPorts->sLCFLaneData.afValidLength_met[3] = 100.f;
pLCFSENreqPorts->sLCFLaneData.auColor_nu[3] = 0U;
pLCFSENreqPorts->sLCFLaneData.auEventQuality_nu[3] = 0u;
pLCFSENreqPorts->sLCFLaneData.auEventType_nu[3] = 0u;
pLCFSENreqPorts->sLCFLaneData.auMarkerType_nu[3] = 2U;
pLCFSENreqPorts->sLCFLaneData.auQuality_nu[3] = 100U;

for (UINT8_T ii = 0; ii < 20; ii++) {
    fPosXPre[ii] = (50.f) * ii / (20 - 1.0F);
    fPosYPre[ii] =
        TUE_CML_PosY3rd_M(fPosXPre[ii], fLastY0[0], fLastHeading[0],
                            fLastCurvature[0], fLastCurvatureRate[0]);
}
fDeltaYaw = fvehYawRate * 0.05F;
fDeltaPosX = TUE_CML_Cos_M(fDeltaYaw) * fvehSpeed * 0.05F;
fDeltaPosY = TUE_CML_Sin_M(fDeltaYaw) * fvehSpeed * 0.05f;

for (UINT8_T ii = 0U; ii < POLYFIT_SAMPLE_POINTS; ii++) {
    fTempLMC = fPosXPre[ii] * TUE_CML_Cos_M(fDeltaYaw) +
                fPosYPre[ii] * TUE_CML_Sin_M(fDeltaYaw);
    fPosXRot[ii] = fTempLMC - fDeltaPosX;
    fTempLMC = fPosYPre[ii] * TUE_CML_Cos_M(fDeltaYaw) -
                fPosXPre[ii] * TUE_CML_Sin_M(fDeltaYaw);
    fPosYRot[ii] = fTempLMC - fDeltaPosY;
}

sPFTInput.bEnable1st = 0U;
sPFTInput.bEnable2nd = 0U;
sPFTInput.bEnable3rd = 1U;

sPFTInput.fFctCrvDecay = 1.0F;
sPFTInput.fFctCrvChngDecay = 1.0F;

for (UINT8_T ii = 0U; ii < 20; ii++) {
    sPFTInput.fFctWeight[ii] = 1.0F;
    sPFTInput.fPosXArray[ii] = fPosXRot[ii];
    sPFTInput.fPosYArray[ii] = fPosYRot[ii];
}

TUE_CML_PolyFit_M(&sPFTInput, &sPFTOutput);

// ====================================>
void TUE_CML_PolyFit_M(const sPFTInput_t* pPFTInput, sPFTOutput_t* pPFTOutput) {
        TUE_CML_CreateMatrix_M(
            mtrxX1st, POLYFIT_SAMPLE_POINTS,
            POLYFIT_ORDER_1ST) /*create X matrix with sample point equations using
                              static memory allocation*/
        TUE_CML_CreateMatrix_M(
            mtrxX2nd, POLYFIT_SAMPLE_POINTS,
            POLYFIT_ORDER_2ND) /*create X matrix with sample point equations
                                  using static memory allocation*/
        TUE_CML_CreateMatrix_M(
            mtrxX3rd, POLYFIT_SAMPLE_POINTS,
            POLYFIT_ORDER_3RD) /*create X matrix with sample point equations
                                  using static memory allocation*/
        TUE_CML_CreateMatrix_M(
            vecY, POLYFIT_SAMPLE_POINTS,
            1) /* vector for object y-position storage which gets filled from
                  input struct and transformed each cycle */
        TUE_CML_CreateMatrix_M(
            vecX, POLYFIT_SAMPLE_POINTS,
            1) /* vector for object x-position storage which gets filled from
                  input struct and transformed each cycle */
        TUE_CML_CreateMatrix_M(vecPolyCoeff1st, POLYFIT_ORDER_1ST,
                               1) /* calculated polynomial coefficients which
                                     are written to the output struct */
        TUE_CML_CreateMatrix_M(vecPolyCoeff2nd, POLYFIT_ORDER_2ND,
                               1) /* calculated polynomial coefficients which
                                     are written to the output struct */
        TUE_CML_CreateMatrix_M(vecPolyCoeff3rd, POLYFIT_ORDER_3RD,
                               1) /* calculated polynomial coefficients which
                                     are written to the output struct */
        TUE_CML_CreateMatrix_M(
            Weight, POLYFIT_SAMPLE_POINTS,
            1) /* weighting factors --> diagonal elements of matrix stored as
                  vector for element-wise calculations */

        /*initialize local variables*/
        UINT8_T bTrajInvalid1st_bool = 0U;
        UINT8_T bTrajInvalid2nd_bool = 0U;
        UINT8_T bTrajInvalid3rd_bool = 0U;

    int i;
    /*Initialize matrices*/
    for (i = 0; i < POLYFIT_SAMPLE_POINTS; i++) {
        TUE_CML_GetMatrixElement_M(vecX, i, 0) = pPFTInput->fPosXArray[i];
        TUE_CML_GetMatrixElement_M(vecY, i, 0) = pPFTInput->fPosYArray[i];
        TUE_CML_GetMatrixElement_M(Weight, i, 0) = pPFTInput->fFctWeight[i];
    }

    /* calculate 1st order fit */
    if (pPFTInput->bEnable1st) {
        createEquationMatrix1st(mtrxX1st, vecX);
        bTrajInvalid1st_bool =
            calculatePolyfit1st(Weight, mtrxX1st, vecY, vecPolyCoeff1st);

        if (!bTrajInvalid1st_bool) {
            pPFTOutput->fPosY01st =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff1st, 0, 0);
            pPFTOutput->fHeading1st = getArcTanSmallAng(
                TUE_CML_GetMatrixElement_M(vecPolyCoeff1st, 1, 0));
            pPFTOutput->fDevToTraj1st =
                getDevToTraj(mtrxX1st, vecY, vecPolyCoeff1st, Weight);

        } else {
            pPFTOutput->fPosY01st = 0.0f;
            pPFTOutput->fHeading1st = 0.0f;
            pPFTOutput->fDevToTraj1st = 0.0f;
        }
        pPFTOutput->bTrajInvalid1st = bTrajInvalid1st_bool;
    } else {
        pPFTOutput->bTrajInvalid1st = 1U;
        pPFTOutput->fPosY01st = 0.0f;
        pPFTOutput->fHeading1st = 0.0f;
        pPFTOutput->fDevToTraj1st = 0.0f;
    }

    /* calculate 2nd order fit */
    if (pPFTInput->bEnable2nd) {
        createEquationMatrix2nd(mtrxX2nd, vecX, pPFTInput->fFctCrvDecay);
        bTrajInvalid2nd_bool =
            calculatePolyfit2nd(Weight, mtrxX2nd, vecY, vecPolyCoeff2nd);

        if (!bTrajInvalid2nd_bool) {
            pPFTOutput->fPosY02nd =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff2nd, 0, 0);
            pPFTOutput->fHeading2nd = getArcTanSmallAng(
                TUE_CML_GetMatrixElement_M(vecPolyCoeff2nd, 1, 0));
            pPFTOutput->fCrv2nd =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff2nd, 2, 0);

            pPFTOutput->fDevToTraj2nd =
                getDevToTraj(mtrxX2nd, vecY, vecPolyCoeff2nd, Weight);

        } else {
            pPFTOutput->fPosY02nd = 0.0f;
            pPFTOutput->fHeading2nd = 0.0f;
            pPFTOutput->fCrv2nd = 0.0f;
            pPFTOutput->fDevToTraj2nd = 0.0f;
        }
        pPFTOutput->bTrajInvalid2nd = bTrajInvalid2nd_bool;
    } else {
        pPFTOutput->bTrajInvalid2nd = 1U;
        pPFTOutput->fPosY02nd = 0.0f;
        pPFTOutput->fHeading2nd = 0.0f;
        pPFTOutput->fCrv2nd = 0.0f;
        pPFTOutput->fDevToTraj2nd = 0.0f;
    }

    /*  calculate 3rd order fit*/
    if (pPFTInput->bEnable3rd) {
        createEquationMatrix3rd(mtrxX3rd, vecX, pPFTInput->fFctCrvDecay,
                                pPFTInput->fFctCrvChngDecay);
        bTrajInvalid3rd_bool =
            calculatePolyfit3rd(Weight, mtrxX3rd, vecY, vecPolyCoeff3rd);

        if (!bTrajInvalid3rd_bool) {
            pPFTOutput->fPosY03rd =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff3rd, 0, 0);
            pPFTOutput->fHeading3rd = getArcTanSmallAng(
                TUE_CML_GetMatrixElement_M(vecPolyCoeff3rd, 1, 0));
            pPFTOutput->fCrv3rd =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff3rd, 2, 0);
            pPFTOutput->fChngOfCrv3rd =
                TUE_CML_GetMatrixElement_M(vecPolyCoeff3rd, 3, 0);

            pPFTOutput->fDevToTraj3rd =
                getDevToTraj(mtrxX3rd, vecY, vecPolyCoeff3rd, Weight);

        } else {
            pPFTOutput->fPosY03rd = 0.0f;
            pPFTOutput->fHeading3rd = 0.0f;
            pPFTOutput->fCrv3rd = 0.0f;
            pPFTOutput->fChngOfCrv3rd = 0.0f;
            pPFTOutput->fDevToTraj3rd = 0.0f;
        }
        pPFTOutput->bTrajInvalid3rd = bTrajInvalid3rd_bool;
    } else {
        pPFTOutput->bTrajInvalid3rd = 1U;
        pPFTOutput->fPosY03rd = 0.0f;
        pPFTOutput->fHeading3rd = 0.0f;
        pPFTOutput->fCrv3rd = 0.0f;
        pPFTOutput->fChngOfCrv3rd = 0.0f;
        pPFTOutput->fDevToTraj3rd = 0.0f;
    }
}
//============.h 文件中应该含有的
/*
TUE_CML_CreateMatrix_M：这个宏定义用于创建一个矩阵。
它首先声明一个静态的浮点数组来存储矩阵数据，数组大小为矩阵的行数乘以列数。
然后，它声明一个 TUE_CML_sMatrix_t 类型的结构体，用于存储矩阵的维度和数据指针。
最后，它将这个结构体的地址赋给一个指针，作为矩阵的引用。
*/
#define TUE_CML_CreateMatrix_M(name, rows, cols)                          \
    static REAL32_T fMtrxData##name[(UINT32_T)(rows) * (UINT32_T)(cols)]; \
    TUE_CML_sMatrix_t AlgoMtrxHeader##name = {                            \
        {(UINT8_T)(cols), (UINT8_T)(rows),                                \
         (UINT16_T)((UINT32_T)(rows) * (UINT32_T)(cols))},                \
        fMtrxData##name};                                                 \
    TUE_CML_sMatrix_t* name =                                             \
        &AlgoMtrxHeader##name;  ///< Creates matrix and allocates new payload
                                ///< data with global scope
/*
    
TUE_CML_GetMatrixElement_M：这个宏定义用于访问矩阵的特定元素。
它通过计算元素在数组中的索引来获取值，索引计算基于元素的行号和列号
*/
#define TUE_CML_GetMatrixElement_M(name, Row, Col) \
    (name)->pData[(UINT32_T)(Col) +                \
                  ((UINT32_T)(Row) *               \
                   (name)->Desc.col)]  ///<  Access to matrix element

static REAL32_T getArcTanSmallAng(REAL32_T x) {
    REAL32_T fArcTan = 0.0f;
    /* − 1 ≤ x ≤ 1 */
    if (x > 1.0f) {
        x = 1.0f;
    } else if (x < -1.0f) {
        x = -1.0f;
    }
    fArcTan = x / (1.0F + (0.28086F * x * x));
    return fArcTan;
}
// ==============》数据结构
typedef struct {
    UINT8_T bEnable1st;        /*enable 1st order fit*/
    UINT8_T bEnable2nd;        /*enable 2nd order fit*/
    UINT8_T bEnable3rd;        /*enable 3rd order fit*/
    REAL32_T fFctCrvDecay;     /* Curvature change decay factor for polyfit */
    REAL32_T fFctCrvChngDecay; /* Curvature change decay factor for polyfit */
    REAL32_T fPosXArray[POLYFIT_SAMPLE_POINTS]; /*array of x values*/
    REAL32_T fPosYArray[POLYFIT_SAMPLE_POINTS]; /*array of y values*/
    REAL32_T fFctWeight[POLYFIT_SAMPLE_POINTS]; /*weighting for each point*/
} sPFTInput_t;
typedef struct {
    REAL32_T fPosY01st;
    REAL32_T fPosY02nd;
    REAL32_T fPosY03rd;
    REAL32_T fHeading1st;
    REAL32_T fHeading2nd;
    REAL32_T fHeading3rd;
    REAL32_T fCrv2nd;
    REAL32_T fCrv3rd;
    REAL32_T fChngOfCrv3rd;
    UINT8_T bTrajInvalid1st;
    UINT8_T bTrajInvalid2nd;
    UINT8_T bTrajInvalid3rd;
    REAL32_T fDevToTraj1st;
    REAL32_T fDevToTraj2nd;
    REAL32_T fDevToTraj3rd;
} sPFTOutput_t;
#define POLYFIT_SAMPLE_POINTS (20U)
